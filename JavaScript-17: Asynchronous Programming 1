Q1. Async JS 1: Declaring async function

Question: Which keyword is used to declare an asynchronous function in JavaScript?

Options:

- sync
- async
- await
- promise

Explanation:

- sync: This is not a keyword used for asynchronous operations. It suggests synchronous behavior.
- async: This is the correct keyword used to declare an asynchronous function in JavaScript. Functions declared with the async keyword return a promise implicitly.
- await: This keyword is used inside an async function to pause execution until a promise is resolved.
- promise: This is a JavaScript object used for asynchronous operations, but it's not a keyword used to declare an asynchronous function.

So, the correct answer is **async**.

Q2. Async JS 1: Creating resolved promise

Question: Which method is used to explicitly create a resolved promise in JavaScript?

Options:

- Promise.reject()
- Promise.resolve()
- Promise.all()
- Promise.race()

Explanation:

- Promise.reject(): This method is used to explicitly create a rejected promise.
- Promise.resolve(): This method is used to explicitly create a resolved promise.
- Promise.all(): This method is used to combine multiple promises into a single promise that resolves when all of the input promises have resolved.
- Promise.race(): This method is used to race multiple promises against each other, returning the first one that resolves or rejects.

So, the correct answer is **Promise.resolve()**.

Q3. Async JS 1: Catching errors

Question: Which method is used to catch errors in an asynchronous function?

Options:

- try-catch statement
- catch() method
- then() method
- finally() method

Explanation:

- try-catch statement: This is a control flow statement for handling exceptions. It's used to catch errors in synchronous code, but it doesn't directly handle asynchronous errors.
- catch() method: This method is used to handle errors in promises. It's used in conjunction with the then() method to handle both successful and failed promises.
- then() method: This method is used to handle the resolved value of a promise. While it can handle errors using the second argument of then(), it's not specifically for catching errors.
- finally() method: This method is used to execute code after a promise is settled (either resolved or rejected), regardless of its outcome. It's not primarily used for catching errors.

So, the correct answer is **catch() method**.

Q4. Async JS 1: Awaiting promise

Question: Which operator is used to await a promise inside an async function?

Options:

- && operator
- || operator
- + operator
- await operator

Explanation:

- && operator: This is the logical AND operator used for boolean operations. It is not used to await promises.
- || operator: This is the logical OR operator used for boolean operations. It is not used to await promises.
- + operator: This is the addition operator used for arithmetic operations. It is not used to await promises.
- await operator: This is the correct operator used to pause execution within an async function until a promise is settled (resolved or rejected).

So, the correct answer is **await operator**.

Q5. Async JS 1: Delay in execution

Question: Which method is used to delay the execution of code in JavaScript?

Options:

- setTimeout()
- setInterval()
- setImmediate()
- clearTimeout()

Explanation:

- setTimeout(): This method is used to execute a function or an expression after a specified delay (in milliseconds).
- setInterval(): This method is used to repeatedly execute a function or an expression at specified intervals (in milliseconds).
- setImmediate(): This method is used to execute a function asynchronously, after the current event loop cycle.
- clearTimeout(): This method is used to cancel a timeout set with setTimeout().

So, the correct answer is **setTimeout()**.

Q6. Async JS 1: Promise.all()

Question: What does the "Promise.all()" method do?

Options:

- Executes multiple promises in parallel and returns a new promise that resolves when all promises are resolved.
- Executes multiple promises in parallel and returns a new promise that resolves when any promise is resolved.
- Executes multiple promises in sequence and returns a new promise that resolves when all promises are resolved.
- Executes multiple promises in sequence and returns a new promise that resolves when any promise is resolved.

Explanation:

- Executes multiple promises in parallel and returns a new promise that resolves when all promises are resolved.

So, the correct answer is **Executes multiple promises in parallel and returns a new promise that resolves when all promises are resolved**.

Q7. Async JS 1: Chain async Operations

Question: Which method is used to chain multiple asynchronous operations together in JavaScript?

Options:

- then()
- catch()
- finally()
- all()

Explanation:

- then(): This method is used to chain asynchronous operations together and handle the resolved value of a promise.
- catch(): This method is used to handle errors in promises, not specifically for chaining operations.
- finally(): This method is used to execute code after a promise is settled, regardless of its outcome, not for chaining operations.
- all(): There's no native method called all() for chaining asynchronous operations in JavaScript.

So, the correct answer is **then()**.

Q8. Async JS 1: Cleanup Operations

Question: Which method is used to handle cleanup operations after a promise settles?

Options:

- then()
- catch()
- finally()
- all()

Explanation:

- then(): This method is used to handle the resolved value of a promise but is not specifically for cleanup operations.
- catch(): This method is used to handle errors in promises, not for cleanup operations.
- finally(): This method is used to execute code after a promise is settled, regardless of its outcome. It's typically used for cleanup operations.
- all(): There's no native method called all() for cleanup operations in JavaScript promises.

So, the correct answer is **finally()**.

Q9. Async JS 1: Purpose of 'async/await'

Question: What is the purpose of the "async/await" syntax in JavaScript?

Options:

- To make asynchronous code synchronous.
- To make synchronous code asynchronous.
- To handle errors in asynchronous code.
- To handle errors in synchronous code.

Explanation:

- To make synchronous code asynchronous.

The purpose of async/await is to make synchronous code asynchronous, allowing it to wait for asynchronous operations to complete without blocking.

So, the correct answer is **To make synchronous code asynchronous**.

Q10. Async JS 1: Advantage of promises

Question: What is the advantage of using promises in asynchronous JavaScript code?

Options:

- Promises simplify error handling in asynchronous code.
- Promises automatically handle memory management in asynchronous code.
- Promises improve performance in asynchronous code.
- Promises eliminate the need for callbacks in asynchronous code.

Explanation:

- Promises simplify error handling in asynchronous code.

Promises provide a cleaner and more structured way to handle asynchronous operations, especially when it comes to error handling. 

So, the correct answer is **Promises simplify error handling in asynchronous code**.

Q11. Async JS 1: Rejecting promises

Question: Which method is used to reject a promise with a reason?

Options:

- Promise.resolve()
- Promise.reject()
- Promise.catch()
- Promise.finally()

Explanation:

- Promise.resolve(): This method is used to create a resolved promise with a specified value.
- Promise.reject(): This method is used to create a rejected promise with a specified reason.
- Promise.catch(): This method is

 used to handle errors in promises, not for rejecting promises.
- Promise.finally(): This method is used to execute code after a promise is settled, regardless of its outcome.

So, the correct answer is **Promise.reject()**.

Q12. Async JS 1: Purpose of async

Question: What does the "async" keyword do when used before a function definition?

Options:

- It makes the function run asynchronously.
- It automatically converts the function into a promise.
- It ensures the function is executed before other asynchronous code.
- It enables the use of the "await" keyword inside the function.

Explanation:

- It automatically converts the function into a promise.

The "async" keyword before a function definition automatically converts the function into a promise.

So, the correct answer is **It automatically converts the function into a promise**.

Q13. Async JS 1: Combining results

Question: Which method is used to combine the results of multiple promises into a single promise?

Options:

- Promise.combine()
- Promise.merge()
- Promise.all()
- Promise.race()

Explanation:

- Promise.combine(): There is no built-in method called Promise.combine() in JavaScript for combining the results of multiple promises.
- Promise.merge(): There is no built-in method called Promise.merge() in JavaScript for combining the results of multiple promises.
- Promise.all(): This method is used to combine the results of multiple promises into a single promise. It waits for all promises to be resolved and returns an array of their results.
- Promise.race(): This method is used to race multiple promises against each other and returns the value or reason of the first promise that settles.

So, the correct answer is **Promise.all()**.

Q14. Async JS 1: No catch() is used

Question: What happens if a promise is rejected and no "catch()" method is called on it?

Options:

- The program crashes.
- The promise remains in a pending state.
- The error is silently ignored.
- An unhandled promise rejection error is thrown.

Explanation:

- An unhandled promise rejection error is thrown.

If a promise is rejected and no catch() method is called, an unhandled promise rejection error is thrown. This is to alert developers about unhandled errors in their code.

So, the correct answer is **An unhandled promise rejection error is thrown**.

Q15. Async JS 1: Creating new promise

Question: Which method is used to create a new promise in JavaScript?

Options:

- Promise.new()
- new Promise()
- Promise.create()
- createPromise()

Explanation:

- Promise.new(): There's no method called Promise.new() for creating a new promise in JavaScript.
- new Promise(): This is the correct syntax for creating a new promise in JavaScript. It takes a function with two arguments, resolve and reject, as its parameter.
- Promise.create(): There's no method called Promise.create() for creating a new promise in JavaScript.
- createPromise(): There's no built-in method called createPromise() for creating a new promise in JavaScript.

So, the correct answer is **new Promise()**.
